import numpy as np
import matplotlib.pyplot as plt

# ==============================================================================
# KISH LATTICE THEORY: 2T-PHYSICS VISUALIZER
# FILE: lattice_time_dilation.py
# CONCEPT: Time as an Interference Pattern
# LICENSE: Sovereign Protected / Copyright Â© 2026 (SR 1-15080581911)
#
# DESCRIPTION:
# Standard physics assumes time is a single linear dimension (1T).
# Kish Lattice Theory proposes 2T Physics: Time is the interference beat
# generated by the friction between the 24-Dimensional Container (Bosonic Limit)
# and the 16-Dimensional Active Lattice (Heterotic Limit).
#
# This script visualizes how two "invisible" high-frequency clocks create
# the "visible" low-frequency flow of time.
# ==============================================================================

def simulate_2t_clock():
    # --- 1. THE CONFIGURATION ---
    # We use the ratio derived from String Theory limits
    FREQ_CONTAINER = 24.0  # Hz (The Box / Bosonic Limit)
    FREQ_LATTICE   = 16.0  # Hz (The Content / Kish Constant Degrees of Freedom)
    
    # Setup the timeline (1 second duration)
    sample_rate = 1000
    t = np.linspace(0, 1, sample_rate)

    # --- 2. THE HIDDEN CLOCKS (Source 1 & Source 2) ---
    # These represent the high-speed "Reference Frames" of the Universe
    # They are the "Tines" of the tuning fork.
    clock_1 = np.sin(2 * np.pi * FREQ_CONTAINER * t)
    clock_2 = np.sin(2 * np.pi * FREQ_LATTICE * t)

    # --- 3. THE INTERFERENCE (The Reality) ---
    # "1 + 1 = 3"
    # When we add the two waves, we create a Constructive/Destructive pattern.
    # This is the "Moire Pattern" of time.
    reality_wave = clock_1 + clock_2

    # Calculate the Beat Frequency (The "Tick" we actually feel)
    # f_beat = |f1 - f2|
    beat_freq = abs(FREQ_CONTAINER - FREQ_LATTICE)

    # --- 4. VISUALIZATION ---
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12), sharex=True)
    plt.subplots_adjust(hspace=0.4)

    # Plot Clock 1 (The Container)
    ax1.plot(t, clock_1, color='blue', alpha=0.7)
    ax1.set_title(f"Source 1: The Container Clock ({int(FREQ_CONTAINER)} Cycles)", fontsize=12, fontweight='bold')
    ax1.set_ylabel("Amplitude")
    ax1.grid(True, alpha=0.3)

    # Plot Clock 2 (The Lattice)
    ax2.plot(t, clock_2, color='green', alpha=0.7)
    ax2.set_title(f"Source 2: The Lattice Clock ({int(FREQ_LATTICE)} Cycles)", fontsize=12, fontweight='bold')
    ax2.set_ylabel("Amplitude")
    ax2.grid(True, alpha=0.3)

    # Plot The Reality (The Interference Beat)
    ax3.plot(t, reality_wave, color='red', linewidth=2)
    ax3.set_title(f"The Reality: Interference Pattern (Beat Frequency = {int(beat_freq)} Hz)", fontsize=12, fontweight='bold')
    ax3.set_xlabel("Time (Seconds)")
    ax3.set_ylabel("Net Amplitude")
    
    # Highlight the "Nodes" (The Quiet Spots) and "Anti-Nodes" (The Primes)
    # We draw an envelope to show the "Wub Wub" shape
    envelope = 2 * np.cos(2 * np.pi * (beat_freq / 2) * t)
    ax3.plot(t, envelope, color='black', linestyle='--', alpha=0.5, label='The "Time" Envelope')
    ax3.legend(loc='upper right')
    ax3.grid(True, alpha=0.3)

    # Annotate the math
    plt.suptitle("Kish Lattice: The Origin of Time (2T Interference)", fontsize=16)
    
    print(f"[*] Simulation Complete.")
    print(f"[*] Source A: {FREQ_CONTAINER} Hz")
    print(f"[*] Source B: {FREQ_LATTICE} Hz")
    print(f"[*] Resulting Beat (Time Flow): {beat_freq} Hz")
    print(f"[*] Ratio: {FREQ_CONTAINER/FREQ_LATTICE} (Perfect Fifth / 3:2)")

    plt.savefig('kish_time_dilation.png')
    plt.show()

if __name__ == "__main__":
    simulate_2t_clock()
